/*
 * LedCube.cpp
 *
 * Created: 01.02.2019 11:21:33
 * Author : Barthap
 */ 
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdlib.h>

#include "globals.h"
#include "Cube.h"
#include "EffectLauncher.h"

#include "Drawing.h"

uint32_t micros = 0;

inline void initRenderTimer()
{
		// Timer 2
		// Frame buffer interrupt
		// 14745600/128/11 = 10472.72 interrupts per second
		// 10472.72/8 = 1309 frames per second
		OCR2 = 10; 	// interrupt at counter = 10
		TCCR2 |= (1 << CS20) | (1 << CS22); // Prescaler = 128.
		TCCR2 |= (1 << WGM21); // CTC mode. Reset counter when OCR2 is reached.
		TCNT2 = 0x00;	// initial counter value = 0;
		TIMSK |= (1 << OCIE2); // Enable CTC interrupt
}

inline void initSystemTimer()
{
	//14745600/8/2 = 921,6 kHz = 1,08 us
	OCR0 = 1;	//interrupt at 1
	TCCR0 |= (1 << CS01);	//Prescaler = 8
	TCCR0 |= (1 << WGM01);	//CTC mode
	TCNT0 = 0;	//start from 0
	TIMSK |= (1 << OCIE0);
}

inline void initUart()
{
	    // Initiate RS232
	    // USART Baud rate is defined in MYUBRR
	    UBRRH = MYUBRR >> 8;
	    UBRRL = MYUBRR;
	    // UCSRC - USART control register
	    // bit 7-6      sync/ascyn 00 = async,  01 = sync
	    // bit 5-4      parity 00 = disabled
	    // bit 3        stop bits 0 = 1 bit  1 = 2 bits
	    // bit 2-1      frame length 11 = 8
	    // bit 0        clock polarity = 0
	    UCSRC  = 0b10000110;
	    // Enable RS232, tx and rx
	    UCSRB = (1<<RXEN)|(1<<TXEN);
	    UDR = 0x00; // send an empty byte to indicate powerup.
}

void init()
{
	DDRA = 0xFF;
	DDRB = 0x1F;
	DDRC = 0xFF;
	
	DATA_BUS = 0x00;
	LAYER_SELECT = 0x00;
	
	PORTB |= (1 << LED_PIN);
	
	//initSystemTimer();
	initRenderTimer();
	
	initUart();
}

void rs232();

int main(void)
{
	init();
	current_layer = 1;
	
	srand(PORTD);
	
	sei();

	EffectLauncher launcher;
	
	//rs232();
	
    while (1) 
    {
		//launcher.launch(EffectId::STRINGFLY2);
		//launcher.launch(EffectId::HEART_SPIN);
		for (uint8_t i=0; i<EFFECTS_TOTAL; i++)
			launcher.launch(static_cast<const EffectId>(i));
    }
}


/*
 * Multiplexer/frame buffer routine
 * This function is called by an interrupt generated by timer 2.
 * Every time it runs, it does the following:
 * 1) Disable the output for the multiplexer array.
 * 2) Turn of all layers.
 * 3) Load the current layer from the cube buffer onto the
 *    multiplexer array.
 * 4) Enable output from the multiplexer array.
 * 5) Turn on the current layer.
 * 6) Increment the current_layer variable, so the next layer is
 *    drawn the next time this function runs.
*/

ISR(TIMER2_COMP_vect)
{
	micros++;
	
	int i;

	LAYER_SELECT = 0x00; // Turn all cathode layers off. (all transistors off)
	OE_PORT |= OE_MASK; // Set OE high, disabling all outputs on latch array

	// Loop through all 8 bytes of data in the current layer
	// and latch it onto the cube.
	for (i = 0; i < 8; i++)
	{
		// Set the data on the data-bus of the latch array.
		PORTA = cube[current_layer][i];
		// Increment the latch address chip, 74HC138, to create
		// a rising edge (LOW to HIGH) on the current latch.
		LATCH_ADDR = (LATCH_ADDR & LATCH_MASK_INV) | (LATCH_MASK & (i+1));
	}

	OE_PORT &= ~OE_MASK; // Set OE low, enabling outputs on the latch array
	LAYER_SELECT = (0x01 << current_layer); // Transistor ON for current layer

	// Increment the curren_layer counter so that the next layer is
	// drawn the next time this function runs.
	current_layer++;
	// We want to count from 0-7, so set it to 0 when it reaches 8.
	if (current_layer == 8)
		current_layer = 0;
}

ISR(TIMER0_COMP_vect)
{
	
}

// Take input from a computer and load it onto the cube buffer
void rs232()
{
	int tempval;
	int x = 0;
	int y = 0;
	int escape = 0;
	
	while (escape < 2)
	{

		// Wait until a byte has been received
		while ( !(UCSRA & (1<<RXC)) );

		// Load the received byte from rs232 into a buffer.
		tempval = UDR;

		// Uncommet this to echo data back to the computer
		// for debugging purposes.
		//UDR = tempval;

		// Every time the cube receives a 0xff byte,
		// it goes into sync escape mode.
		// if a 0x00 byte is then received, the x and y counters
		// are reset to 0. This way the x and y counters are
		// always the same on the computer and in the cube.
		// To send an 0xff byte, you have to send it twice!

		// Go into sync escape mode
		if (tempval == 0xff)
		{
			// Wait for the next byte
			while ( !(UCSRA & (1<<RXC)) );
			// Get the next byte
			tempval = UDR;

			// Sync signal is received.
			// Reset x and y counters to 0.
			if (tempval == 0x00)
			{
				x = 0;
				y = 0;
				escape = 1;
			}
			// if no 0x00 byte is received, proceed with
			// the byte we just received.
		}

		if (escape == 0)
		{
			// Load data into the current position in the buffer
			fb[x][y] = tempval;

			// Check if we have reached the limits of the buffer array.
			if (y == 7)
			{
				if (x == 7)
				{
					// All data is loaded. Reset both counters
					y = 0;
					x = 0;
					// Copy the data onto the cube.
					flipBuffer();
				} else
				{
					// A layer is loaded, reset y and increment x.
					x++;
					y = 0;
				}
			} else
			{
				// We are in the middle of loading a layer. increment y.
				y++;
			}
			
		} else
		{
			escape = 0;
			for (uint8_t i = 0; i < 4; i++)
			{
				while ( !(UCSRA & (1<<RXC)) );
				uint8_t rec = UDR;
				if(i == 0 && rec != 0xDE) break;
				if(i == 1 && rec != 0xAD) break; 
				if(i == 2 && rec != 0xBE) break; 
				if(i == 3 && rec != 0xEF)
					break; 
				else {
					escape = 2;
					UDR = 'x';
					break;
				}
			}
			
		}
	}
}